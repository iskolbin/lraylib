local is_int = {
	['int'] = true, ['unsigned'] = true, ['unsigned int'] = true,
	['signed int'] = true, ['signed'] = true,
	['short int'] = true, ['unsigned short'] = true, ['unsigned short int'] = true,
	['signed short int'] = true, ['signed short'] = true,
	['char'] = true, ['unsigned char'] = true, ['signed char'] = true,
}

local is_number = {
	['long'] = true, ['unsigned long'] = true, ['unsigned long int'] = true,
	['signed long'] = true, ['signed long int'] = true,
	['float'] = true, ['double'] = true,
}

local function print_prelude(name, defines, includes)
	print('// Autogenerated library bindings l' .. tostring(name))
	print('// Generator by iskolbin https://github.com/iskolbin/lraylib')
	print()
	print('#include <stdlib.h>')
	print()
	print('#include <lua.h>')
	print('#include <lauxlib.h>')
	print('#include <lualib.h>')
	for _, define in ipairs(defines or {}) do
		print('#define ' .. define)
	end
	for _, include in ipairs(includes or {}) do
		print('#include "' .. include .. '"')
	end
	print()
	print('// Lua 5.1 compatibility')
	print('#if (LUA_VERSION_NUM <= 501)')
	print('#define LUAMOD_API LUALIB_API')
	print('#define luaL_newlib(L,lib) luaL_register(L,"' .. name .. '",lib)')
	print('#define luaL_setfuncs(L,l,z) luaL_register(L,NULL,l)')
	print('#define luaL_setmetatable(L,mt) luaL_getmetatable(L,mt);lua_setmetatable(L,-2)')
	print('#define lua_rawlen lua_objlen')
	print('#endif')
end

local function analyze_structs_primitivity(api)
	local is_primitive = {["char *"] = true}
	for k in pairs(is_int) do
		is_primitive[k] = true
	end
	for k in pairs(is_number) do
		is_primitive[k] = true
	end
	for _, struct in ipairs(api.structs) do
		local is_primitive_struct = true
		for _, field in ipairs(struct.fields) do
			if not is_primitive[field.type] then
				is_primitive_struct = false
				break
			end
		end
		if is_primitive_struct then
			is_primitive[struct.name] = struct
		end
	end
	for k, v in pairs(is_primitive) do
		is_primitive["const " .. k] = v
	end
	return is_primitive
end

local function to_lua(name, T, ref)
	name = name or 'result'
	if is_int[T] then
		return "lua_pushinteger(L, " .. name .. ");"
	elseif is_number[T] then
		return "lua_pushnumber(L, " .. name .. ");"
	elseif T == "const char *" or T == "char *" then
		return "lua_pushstring(L, " .. name .. ");"
	elseif T == 'bool' then
		return "lua_pushboolean(L, " .. name .. ");"
	else
		local nilcheck = "if (" .. name .. " == NULL) lua_pushnil(L); else "
		return nilcheck .. "{ " .. T .. " *userdata = lua_newuserdata(L, sizeof *userdata); *userdata = " .. name .. "; luaL_setmetatable(L, \"" .. T .. "\");}"
	end
end

local function from_lua(T, index, ref)
	if is_int[T] then
		return "luaL_checkinteger(L, " .. index .. ")"
	elseif is_number[T] then
		return "luaL_checknumber(L, " .. index .. ")"
	elseif T == "const char *" then
		return "luaL_checkstring(L, " .. index .. ")"
	elseif T == "char *" then
		return "(char *)luaL_checkstring(L, " .. index .. ")"
	elseif T == "bool" then
		return "lua_toboolean(L, " .. index .. ")"
	else
		return "(" .. T .. ")luaL_checkudata(L, " .. index .. ", \"" .. T .. "\")"
	end
end

local function gen_function(f, api, is_primitive)
	print("")
	if f.description then
		print("// " .. f.description)
	end
	print("static int l_" .. f.name .. "(lua_State *L) {")
	if (not f.params or #f.params == 0) and (not f.returnType or f.returnType == "void") then
		print('  (void)L; // Suppress unused warning')
	end
	for i, param in ipairs(f.params or {}) do
		if is_primitive[param.type] ~= true then
			print('  return luaL_error(L, "\'' .. f.name .. '\' is unimplemented, cannot convert \'' .. param.name .. '\' parameter of type \'' .. param.type .. '\'");\n}')
			return
		end
	end
	if f.returnType ~= "void" and not to_lua("result", f.returnType) then--not is_primitive[f.returnType] then
		print('  return luaL_error(L, "\'' .. f.name .. '\' is unimplemented, cannot convert return parameter of type \'' .. f.returnType .. '\'");\n}')
		return
	end
	local arg_names = {}
	for i, param in ipairs(f.params or {}) do
		print('  ' .. param.type .. ' ' .. param.name .. ' = ' .. from_lua(param.type, i) .. ';')
		arg_names[i] = param.name
	end
	local call_function = f.name .. "(" .. table.concat(arg_names, ", ") .. ")"
	if f.returnType and f.returnType ~= "void" then
		print("  " .. f.returnType .. " result = " .. call_function .. ";")
		print("  " .. to_lua("result", f.returnType))
		print("  return 1;")
	else
		print("  " .. call_function .. ";")
		print("  return 0;")
	end
	print("}")
end

local function generate_function_bindings(api, is_primitive)
	for _, f in ipairs(api.functions) do
		gen_function(f, api, is_primitive)
	end
end

local function generate_lua_bindings(name, api)	
	print_prelude(name)
	is_primitive = analyze_structs_primitivity(api)
	generate_function_bindings(api, is_primitive)
end

generate_lua_bindings("raylib", require("raylib_api"))
