local is_int = {
	['int'] = true, ['unsigned'] = true, ['unsigned int'] = true,
	['signed int'] = true, ['signed'] = true,
	['short int'] = true, ['unsigned short'] = true, ['unsigned short int'] = true,
	['signed short int'] = true, ['signed short'] = true,
	['char'] = true, ['unsigned char'] = true, ['signed char'] = true,
}

local is_number = {
	['long'] = true, ['unsigned long'] = true, ['unsigned long int'] = true,
	['signed long'] = true, ['signed long int'] = true,
	['float'] = true, ['double'] = true,
}


local alias = {
	Texture2D = 'Texture',
	TextureCubemap = 'Texture',
	RenderTexture2D = 'RenderTexture',
	Quarternion = 'Vector4',
	Camera = 'Camera3D',
}

local is_jsonable, is_primitive = {}, {}

local function print_prelude(name, defines, includes)
	print('// Autogenerated library bindings l' .. tostring(name))
	print('// Generator by iskolbin https://github.com/iskolbin/lraylib')
	print()
	print('#include <stdlib.h>')
	print()
	print('#include <lua.h>')
	print('#include <lauxlib.h>')
	print('#include <lualib.h>')
	for _, define in ipairs(defines or {}) do
		print('#define ' .. define)
	end
	for _, include in ipairs(includes or {}) do
		print('#include "' .. include .. '"')
	end
	print()
	print('// Lua 5.1 compatibility')
	print('#if (LUA_VERSION_NUM <= 501)')
	print('#define LUAMOD_API LUALIB_API')
	print('#define luaL_newlib(L,lib) luaL_register(L,"' .. name .. '",lib)')
	print('#define luaL_setfuncs(L,l,z) luaL_register(L,NULL,l)')
	print('#define luaL_setmetatable(L,mt) luaL_getmetatable(L,mt);lua_setmetatable(L,-2)')
	print('#define lua_rawlen lua_objlen')
	print('#endif')
end

local function analyze_structs_primitivity(api)
	local is_primitive = {["void"] = true, ["char *"] = true, ["bool"] = true}
	local is_jsonable = {}
	for k in pairs(is_int) do
		is_primitive[k] = true
		is_jsonable[k] = true
	end
	for k in pairs(is_number) do
		is_primitive[k] = true
		is_jsonable[k] = true
	end
	for _, struct in ipairs(api.structs) do
		local is_jsonable_struct = true
		for _, field in ipairs(struct.fields) do
			local t = alias[field.type] or field.type
			if not is_jsonable[field.type] then
				is_jsonable_struct = false
				break
			end
		end
		if is_jsonable_struct then
			is_jsonable[struct.name] = struct
		end
	end
	for k, v in pairs(is_primitive) do
		is_primitive["const " .. k] = v
		is_jsonable["const " .. k] = v
	end
	return is_primitive, is_jsonable
end

local function unref(T)
	local s = T:gsub(" %*", ""):gsub("%*", "")
	return s
end

local function convert_to_arr(T)
	return T:sub(1,1):upper() .. T:sub(2):gsub("%s[a-z]", function(s) return s:sub(2):upper() end) .. "Array"
end

local function to_lua(name, T)
	name = name or 'result'
	if is_int[T] then
		return "lua_pushinteger(L, " .. name .. ");"
	elseif is_number[T] then
		return "lua_pushnumber(L, " .. name .. ");"
	elseif T == "const char *" or T == "char *" then
		return "lua_pushstring(L, " .. name .. ");"
	elseif T == 'bool' then
		return "lua_pushboolean(L, " .. name .. ");"
	else
		local _, ref = T:gsub("%*", "")
		T = unref(T)
		if ref > 1 or not is_jsonable[T] then
			return
		end
		local nilcheck = "if (" .. name .. " == NULL) lua_pushnil(L); else "
		if ref == 0 then
			return nilcheck .. "{ " .. T .. " *udata = lua_newuserdata(L, sizeof *userdata); *udata = " .. name .. "; luaL_setmetatable(L, \"" .. T .. "\");}"
		elseif ref == 1 then
			return nilcheck .. "{ " .. convert_to_arr(T) .. " *udata = lua_newuserdata(L, sizeof *udata); udata->data = " .. name .. "; luaL_setmetatable(L, \"" .. convert_to_arr(T) .. "\");}"
		end
	end
end

local function from_lua(T, index)
	if is_int[T] then
		return "luaL_checkinteger(L, " .. index .. ")"
	elseif is_number[T] then
		return "luaL_checknumber(L, " .. index .. ")"
	elseif T == "const char *" then
		return "luaL_checkstring(L, " .. index .. ")"
	elseif T == "char *" then
		return "(char *)luaL_checkstring(L, " .. index .. ")"
	elseif T == "bool" then
		return "lua_toboolean(L, " .. index .. ")"
	else
		local _, ref = T:gsub("%*", "")
		T = unref(T)
		if ref > 1 or not is_jsonable[T] then
			return
		end
		if ref == 0 then
			return "*(" .. T .. "*)luaL_checkudata(L, " .. index .. ", \"" .. T .. "\")"
		elseif ref == 1 then
			return "(" .. convert_to_arr(T) .. "*)luaL_checkudata(L, " .. index .. ", \"" .. convert_to_arr(T) .. "\")->data"
		end
	end
end

local function gen_function(f, api, is_primitive, is_jsonable)
	print("")
	if f.description then
		print("// " .. f.description)
	end
	print("static int l_" .. f.name .. "(lua_State *L) {")
	if (not f.params or #f.params == 0) and (not f.returnType or f.returnType == "void") then
		print('  (void)L; // Suppress unused warning')
	end
	for i, param in ipairs(f.params or {}) do
		local t = alias[param.type] or param.type
		if not from_lua(t, i) then
			print('  return luaL_error(L, "\'' .. f.name .. '\' is unimplemented, cannot convert \'' .. param.name .. '\' parameter of type \'' .. t .. '\'");\n}')
			return
		end
	end
	local rt = alias[f.returnType] or f.returnType
	if rt ~= "void" and not to_lua("result", rt) then
		print('  return luaL_error(L, "\'' .. f.name .. '\' is unimplemented, cannot convert return parameter of type \'' .. rt .. '\'");\n}')
		return
	end
	local arg_names = {}
	for i, param in ipairs(f.params or {}) do
		local t = alias[param.type] or param.type
		print("  " .. t .. (t:find("%*") and "" or " ") .. param.name .. " = " .. from_lua(t, i) .. ';')
		arg_names[i] = param.name
	end
	local call_function = f.name .. "(" .. table.concat(arg_names, ", ") .. ")"
	if rt and rt ~= "void" then
		print("  " .. rt .. (rt:find("%*") and "" or " ") .. "result = " .. call_function .. ";")
		print("  " .. to_lua("result", rt))
		print("  return 1;")
	else
		print("  " .. call_function .. ";")
		print("  return 0;")
	end
	print("}")
end

local function generate_function_bindings(api, is_primitive, is_jsonable)
	for _, f in ipairs(api.functions) do
		gen_function(f, api, is_primitive, is_jsonable)
	end
end

local function generate_lua_bindings(name, api)	
	is_primitive, is_jsonable = analyze_structs_primitivity(api)
	print_prelude(name)
	generate_function_bindings(api, is_primitive, is_jsonable)
end

local path, name, module_name = ...
package.path = package.path .. ';' .. path
generate_lua_bindings(name, require(module_name))
